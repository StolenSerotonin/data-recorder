"""
Copyright (C) 2023  Benjamin Secker, Jolon Behrent, Louis Li, James Quilty

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.


Driver for the tipping bucket rain gauge counter.

Provides a Counter class with methods for reading, resetting and
testing the count of square wave pulse events generated by the rain
gauge's reed switch when the bucket tips.
"""

import logging
import time
import pcf8574
from machine import Pin, I2C
from micropython import const

log = logging.getLogger("counter")
# Enable the following to set a log level specific to this module:
# log.setLevel(logging.DEBUG)


RAIN_RESET = const(7)  # PCF8574A I/O port P7 (physical pin 12)
RAIN_CLK = const(5)  # ESP32 GPIO 5 (physical pin 29)
RAIN_CE = const(6)  # PCF8574A I/O port P6 (physical pin 11)
_LSB = const(0)  # PCF8574A I/O port P0 (physical pin 4)
_MSB = const(5)  # PCF8574A I/O port P5 (physical pin 10)


class Counter:
    """
    A class representing the rain gauge bucket tip counter.

    Methods:
    initialise()
        Configures the counter and I/O pins for normal operation.
    get_rainfall()
        Reads and resets the tip counter; returns an integer count.
    enable()
        Sets the Counter Enable pin active; tips will be counted.
    disable()
        Sets the Counter Enable pin inactive; tips will not be counted.
    read()
        Reads the tip count without resetting the count.
    reset()
        Sets the tip count to 0.
    """

    def __init__(self) -> None:
        """
        Initialise the io_extender and clk_pin instance attributes.

        NOTE: a Counter object is instantiated on every wake-from-sleep
        and thus __init__() must not reset gauge counter state. Use
        initialise() to reset the counter state.
        """
        self.io_extender = pcf8574.PCF8574(I2C(0), 0x38)
        self.clk_pin = Pin(RAIN_CLK, Pin.IN)

    def initialise(self) -> None:
        """
        Initialise the counter for use by creating PCF8574A and ESP32 Pin
        objects and configuring the 74HC590 inputs for normal operation.

        The 74HC590 Master Reset Counter `_MRC` and Counter Enable `_CE`
        inputs are active LOW. For normal operation `_MRC` must be set HIGH (
        inactive) and `_CE` set LOW (active).

        On power-up the Rev::4.0 counter circuit can be in a state which can
        cause the PCF8574A to throw errors on read (#543). The state 0bxx111111
        (0d63) is fairly common on startup and particularly problematic for the
        PCF8574A to read. Reset the counter as part of initialisation.
        """
        self.io_extender.pin(RAIN_RESET, 1)
        self.io_extender.pin(RAIN_CE, 0)

        self.reset()

    def get_rainfall(self):
        """
        Reads the count of external reed switch or microswitch closure events
        from the 74HC590 8-bit binary counter via the PCF8574A I/O Expander,
        returning the counter value in decimal.

        NOTE:
            Includes hardware bug workaround (#541)
            Resets the 74HC590 counter after reading the count register.

        Returns:
            int: the decimal count
        """

        count = self.read()

        # Always reset the rain gauge counter after reading the value.
        self.reset()

        log.info("Current count is: {:d}".format(count))

        return count

    def enable(self):
        """
        Enable the 8-bit counter by setting the 74HC590 Count Enable
        `_CE` input LOW (active).
        """
        self.io_extender.pin(RAIN_CE, 0)

    def disable(self):
        """
        Disable the 8-bit counter by setting the 74HC590 Count Enable
        `_CE` input HIGH (inactive).
        """
        self.io_extender.pin(RAIN_CE, 1)

    def read(self):
        """
        Reads the 6 least significant bits from the 74HC590 8-bit binary
        counter via the PCF8574A I/O Expander, returning the counter value
        in decimal.

        Returns:
            int: the decimal count
        """

        try:
            self.disable()
            # Required in Rev::4.0 because the 8-bit storage register (output
            # register) value is updated when a bucket tip is counted and we
            # don't want an update to occur while reading the output register
            # value. This behaviour is caused by the direct connection of the
            # counter and output register clocks in Rev::4.
            #
            # Note: the 74HC590 datasheet section 1 says "If both clocks are
            # connected together, the counter state is always one count ahead of
            # the register".

            count = self.io_extender.port & 0b00111111
            # Read the entire PCF8574A 8-bit port and use a bitwise AND to
            # obtain only the lower 6 bits which are connected, as inputs,
            # to the lower 6 bits of the 74HC590 output port. See the
            # Rev::4.0 rain_gauge schematics.

            self.enable()
            # Required in Rev::4.0, per comments on self.disable() above.

        except OSError as exc:
            log.critical("PCF8574A communication error {0}".format(exc))
            self.__error_recovery()
            return None
        else:
            return count

    def reset(self):
        """
        Reset the output register to 0b00000000 by resetting the counter and
        clocking the value into the output register via the CPR input.

        Rev::4.0 has the CPR and CPC clock inputs connected so after reset the
        counter state will be one count ahead of the register, i.e. 0b00000001.
        This is normal, as noted in the datasheet.
        """

        self.__pulse_mcr()
        self.__pulse_cpr()

    def __pulse_mcr(self):
        """
        Generate a short square-wave pulse from the PCF8574A to reset the
        74HC590 8-bit binary counter (but not the output register). The
        counter is reset by briefly setting the Master Reset Clock `_MRC`
        pin LOW, i.e. a negative pulse.

        The 74HC590 8-bit Binary Counter Datasheet specifies a `_MCR` minimum
        pulse width of 19 ns for Vcc = 4.5 V and 95 ns for Vcc = 2.0 V,
        and the same duration as the recovery time for `CPC` to accept (count)
        input (Table 7 Dynamic characteristics and Figure 10). We operate at
        Vcc = 3.3 V and will use an `_MRC` pulse width and `CPC` recovery
        time 10 times longer than the longest minimum to be safe.
        """

        self.io_extender.pin(RAIN_RESET, 0)
        time.sleep_us(1)
        self.io_extender.pin(RAIN_RESET, 1)
        time.sleep_us(1)

    def __pulse_cpr(self):
        """
        Generate a short square-wave pulse from the PCF8574A to the
        74HC590 `CPR` input, to "clock" the value from the counter into the
        output register.

        Note: the `CPC` and `CPR` inputs are connected in Rev::4.0, so this
        will also increment the counter by 1. This is normal for the Rev::4.0
        rain gauge counter design.

        The 74HC590 8-bit Binary Counter Datasheet specifies a minimum pulse
        width of 25 ns for Vcc = 4.5 V and 125 ns for Vcc = 2.0 V (Table 7
        Dynamic characteristics). As we operate at Vcc = 3.3 V, make the
        width of this "short" pulse 8 times longer than the longest minimum
        to be safe.

        The datasheet also says that there is no action, neither count nor
        change in the output register, on a falling edge. Retain the falling
        edge for the purpose of observing that the circuit is operating as
        expected under typical input. Set the period before and after the
        pulse to the same as the minimum pulse width, to ensure the circuit
        is settled.

        Restore the pin to input mode, for the purpose of avoiding
        interfering with the reed switch signal conditioning circuit. That
        the ESP32 is not interfering in this state requires verification,
        see #541.
        """
        # Change to output mode
        self.clk_pin.init(mode=Pin.OUT, value=0)
        time.sleep_us(1)
        self.clk_pin.on()  # Use instead of self.clk_pin.value(1)
        time.sleep_us(1)
        self.clk_pin.off()  # Use instead of self.clk_pin.value(1)
        time.sleep_us(1)
        self.clk_pin.init(mode=Pin.IN)

    def __pulse_cpc(self):
        """
        Generate a short square-wave pulse from ESP32 GPIO pin IO2 to the
        74HC590 `CPC` input to increment the counter by 1.

        Note: the `CPC` and `CPR` inputs are connected in Rev::4.0, so simply
        call the __pulse_cpr() function, noting that this call will also store
        the counter value prior to increment in the output register. This is
        normal for the Rev::4.0 rain gauge counter design.
        """
        self.__pulse_cpr()

    def __error_recovery(self):
        """
        Attempt to recover communication with the PCF8574A after an exception
        has been caught.

        Rev::4.0 contains a defect where 'OSError: [Errno 110] ETIMEDOUT' and
        'OSError: [Errno 19] ENODEV' errors can be generated when
        communication is attempted with the PCF8574A I/O extender while the
        74HC590 counter's output register state is 0b00111110 or 0b0111111
        (#543).

        Communication can be restored by incrementing the counter and output
        register past the problematic states, then resetting the counter.
        """

        log.critical("Attempting reset; count data will be lost")
        try:
            self.__pulse_cpc()
            self.__pulse_cpc()
            self.reset()
            reading = self.read()
        except OSError:
            log.critical("Failed to re-establish communication with PCF8574A")
        else:
            if reading == 0:
                log.critical("Re-established communication with PCF8574A")
            else:
                log.critical(
                    "Failed to reset 74HC590 counter; "
                    "read {0} after reset".format(reading)
                )
